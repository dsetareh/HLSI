<!DOCTYPE html>
<!-- Line chart example
Line Chart Checklist

  1.  Add an SVG to draw our line chart on
  2.  Use the D3 standard margin convetion
  3.  Create an x axis
  4.  Create a y axis
  5.  Create an x scale
  6.  Create a y scale
  7.  Create a line generator
  8.  Create a random dataset
  9.  Create a path object for the line
  10. Bind the data to the path object
  11. Call the line generator on the data-bound path object
  12. Add circles to show each datapoint
  13. Add some basic styling to the chart so its easier on the eyes

Read through the code below to see where each part of the checklist is completed.

    from: https://bl.ocks.org/pstuffa/26363646c478b2028d36e7274cedefa6
see also: https://bl.ocks.org/gordlea/27370d1eea8464b04538e6d8ced39e89
-->

<meta charset="utf-8">

<style type="text/css">
/* 13. Basic Styling with CSS */

/* TODO: only apply to axis labels? */
* { font: 12px Arial; }

/* Style the lines by removing the fill and applying a stroke */
.line {
    fill: none;
    stroke: #ffab00;
    stroke-width: 3;
}

.grid line { stroke: #cccccc; }

/* Style the dots by assigning a fill and stroke */
.dot {
    fill: #ffab00;
    stroke: #fff;
}

</style>
<!-- Body tag is where we will append our SVG and SVG objects-->
  <p>
  <label for="bandwidth">Bandwidth</label>
  <input type="range" min="0.1" max="0.9" value="0.1" id="bandwidth" step="0.01" oninput="update_plot(value)">
  <output for="bandwidth" id="bw">0.1</output>
  </p>
<body>
</body>

<!-- Load in the d3 library -->
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="fft.js"></script>
<script>

function update_bandwidth(val) {
    document.querySelector('#bw').value = val;
}

function sinc(t) {
    let r = Math.PI * t;
    return Math.abs(r) < 0.000001 ? 1 : Math.sin(r) / r;
}

function pulse(K,M,W,i) {
    let t = W * (i-K*M)/K;
    let wind = Math.cos(0.5*Math.PI*(i-K*M)/(K*M))**2;
    return sinc(t) * wind;
}

// 2. Use the margin convention practice 
var margin = {top: 50, right: 50, bottom: 50, left: 50}
  , width  = 920 - margin.left - margin.right // Use the window's width 
  , height = 320 - margin.top - margin.bottom; // Use the window's height

// The number of datapoints
var m = 40, k=8, n = 2*k*m+1;
var bw = 0.2;
var nfft = 2048, fft = new FFTNayuki(nfft);
var xi  = new Array(nfft), xq  = new Array(nfft), psd = new Array(nfft);

// 5. X scale will use the index of our data
var xScale = d3.scaleLinear().domain([  -m,   m]).range([0, width]);
var fScale = d3.scaleLinear().domain([-0.5, 0.5]).range([0, width]);

// 6. Y scale will use the randomly generate number 
var yScale = d3.scaleLinear().domain([ -0.25,  1.1]).range([height, 0]);
var pScale = d3.scaleLinear().domain([-80, 30]).range([height, 0]);

// 7. d3's line generator
var linet = d3.line()
    .x(function(d, i) { return xScale((i-k*m)/k); })  // set the x values for the line generator
    .y(function(d)    { return yScale(d.y);       }); // set the y values for the line generator 
    //.curve(d3.curveMonotoneX) // apply smoothing to the line (comment out to remove smoothing)
var linef = d3.line()
    .x(function(d, i) { return fScale(i/nfft-0.5); })  // map frequency
    .y(function(d)    { return pScale(d.y);        }); // map PSD

// 8. An array of objects of length N. Each object has key -> value pair, the key being "y" and the value is a random number
var datat = generate_sinc(0);
var dataf = d3.range(0,nfft-1).map(function(f) { return {"y": 0 } })

// 1. Add the SVG (time) to the page and employ #2
var svgt = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
// frequency SVG object
var svgf = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// 3. Call the x axis in a group tag
svgt.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(xScale)); // Create an axis component with d3.axisBottom
svgf.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(fScale)); // Create an axis component with d3.axisBottom

// 4. Call the y axis in a group tag
svgt.append("g").attr("class", "y axis").call(d3.axisLeft(yScale));
svgf.append("g").attr("class", "y axis").call(d3.axisLeft(pScale));

// add grid lines
svgt.append("g").attr("class","grid").call(d3.axisBottom(xScale).tickFormat("").tickSize(height));
svgt.append("g").attr("class","grid").call(d3.axisLeft  (yScale).tickFormat("").tickSize(-width));
svgf.append("g").attr("class","grid").call(d3.axisBottom(fScale).tickFormat("").tickSize(height));
svgf.append("g").attr("class","grid").call(d3.axisLeft  (pScale).tickFormat("").tickSize(-width));

// add axis labels
svgt.append("text")
    .attr("transform","translate("+(width/2)+","+(height + 0.75*margin.bottom)+")")
    .attr("dy","-0.3em")
    .style("text-anchor","middle")
    .text("Time (sample index)")
svgt.append("text")
    .attr("transform","rotate(-90)")
    .attr("y", 0 - margin.left)
    .attr("x", 0 - (height/2))
    .attr("dy", "1em")
    .style("text-anchor","middle")
    .text("Signal")
svgf.append("text")
    .attr("transform","translate("+(width/2)+","+(height + 0.75*margin.bottom)+")")
    .attr("dy","-0.3em")
    .style("text-anchor","middle")
    .text("Normalized Frequency")
svgf.append("text")
    .attr("transform","rotate(-90)")
    .attr("y", 0 - margin.left)
    .attr("x", 0 - (height/2))
    .attr("dy", "1em")
    .style("text-anchor","middle")
    .text("Power Spectral Density (dB)")

// clip paths
svgt.append("clipPath")
      .attr("id","clipt")
    .append("rect")
      .attr("width",width)
      .attr("height",height);
svgf.append("clipPath")
      .attr("id","clipf")
    .append("rect")
      .attr("width",width)
      .attr("height",height);

// 9. Append the path, bind the data, and call the line generator 
var patht = svgt.append("path")
    .attr("clip-path","url(#clipt)")
    .datum(datat) // 10. Binds data to the line 
    .attr("class", "line") // Assign a class for styling 
    .attr("d", linet);  // 11. Calls the line generator 
var pathf = svgf.append("path")
    .attr("clip-path","url(#clipf)")
    .datum(dataf)
    .attr("class", "line")
    .attr("d", linef);

// 12. Appends a circle for each datapoint 
/*
var dots = svgt.selectAll(".dot")
    .data(datat)
  .enter().append("circle") // Uses the enter().append() method
    .attr("class", "dot") // Assign a class for styling
    .attr("cx", function(d, i) { return xScale(i-m) })
    .attr("cy", function(d) { return yScale(d.y) })
    .attr("r", 5);
*/

// set initial value
update_plot(0.40);

// generate sinc pulse
function generate_sinc(w) {
    //return d3.range(-k*m,k*m).map(function(t) { return {"y": sinc(w*t/k) } })
    return d3.range(0,2*k*m+1).map(function(t) { return {"y": pulse(k,m,w,t) } })
}

// generate power spectral density
function generate_psd(w) {
    // clear buffers
    for (var i=0; i<nfft; i++) {
        xi[i] = 0;
        xq[i] = 0;
    }
    // generate sinc pulse (not up-sampled), TODO: add frequency offset
    for (var i=0; i<2*m+1; i++) {
        //let t = i-m;
        //xi[i] = sinc(w*t);
        xi[i] = pulse(1,m,w,i);
        xq[i] = 0;
    }
    // compute transform in place
    fft.forward(xi,xq);
    // convert to dB
    for (var i=0; i<nfft; i++) {
        psd[(i+nfft/2)%nfft] = 20*Math.log10(1e-6 + Math.sqrt(xi[i]**2 + xq[i]**2));
    }
    //console.log(psd);
    return d3.range(0,nfft-1).map(function(i) { return {"y": psd[i] } })
}

function update_plot(v) {
    document.querySelector('#bw').value = v;
    document.querySelector('#bandwidth').value = v;

    // generate up-sampled time series
    datat = generate_sinc(v);
    patht.datum(datat) // 10. Binds data to the line 
        .attr("class", "line") // Assign a class for styling 
        .attr("d", linet); // 11. Calls the line generator 

    // generate power spectral density
    dataf = generate_psd(v);
    pathf.datum(dataf) // 10. Binds data to the line 
        .attr("class", "line") // Assign a class for styling 
        .attr("d", linef); // 11. Calls the line generator 
}

</script>

